"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = void 0;
var React = require("react");
var dom_1 = require("./dom");
var reactAttributesMap = {
    acceptcharset: 'acceptCharset',
    accesskey: 'accessKey',
    allowfullscreen: 'allowFullScreen',
    autocomplete: 'autoComplete',
    autofocus: 'autoFocus',
    autoplay: 'autoPlay',
    cellpadding: 'cellPadding',
    cellspacing: 'cellSpacing',
    charset: 'charSet',
    class: 'className',
    classid: 'classID',
    colspan: 'colSpan',
    contenteditable: 'contentEditable',
    contextmenu: 'contextMenu',
    controlslist: 'controlsList',
    crossorigin: 'crossOrigin',
    datetime: 'dateTime',
    enctype: 'encType',
    for: 'htmlFor',
    formaction: 'formAction',
    formenctype: 'formEncType',
    formmethod: 'formMethod',
    formnovalidate: 'formNoValidate',
    formtarget: 'formTarget',
    frameborder: 'frameBorder',
    hreflang: 'hrefLang',
    httpequiv: 'httpEquiv',
    inputmode: 'inputMode',
    keyparams: 'keyParams',
    keyyype: 'keyType',
    marginheight: 'marginHeight',
    marginwidth: 'marginWidth',
    maxlength: 'maxLength',
    mediagroup: 'mediaGroup',
    minlength: 'minLength',
    novalidate: 'noValidate',
    radiogroup: 'radioGroup',
    readonly: 'readOnly',
    rowspan: 'rowSpan',
    spellcheck: 'spellCheck',
    srcdoc: 'srcDoc',
    srclang: 'srcLang',
    srcset: 'srcSet',
    tabindex: 'tabIndex',
    usemap: 'useMap',
};
function transformAttributes(attributesMap, options) {
    var attributes = (0, dom_1.getAttributes)(attributesMap);
    var transformedAttributes = {};
    Object.keys(attributes).forEach(function (key) {
        if (reactAttributesMap[key]) {
            transformedAttributes[reactAttributesMap[key]] = attributes[key];
        }
        else {
            transformedAttributes[key] = attributes[key];
        }
        if (!transformedAttributes.key) {
            var isKey = options.useAsKey.some(function (possibleKey) { return possibleKey === key; });
            if (isKey) {
                transformedAttributes.key = attributes[key];
            }
        }
    });
    return transformedAttributes;
}
function renderTextNode(node) {
    return node.nodeValue;
}
function transform(element, options) {
    return {
        attributes: transformAttributes(element.attributes, options),
        childNodes: element.childNodes,
        nodeName: element.nodeName.toLowerCase(),
        nodeType: element.nodeType,
        nodeValue: element.nodeValue,
        override: element.override,
    };
}
function renderElementNode(node, options) {
    var element = transform(node, options);
    if (element.override) {
        return React.cloneElement(element.override(element.attributes, node.textContent));
    }
    if (element.childNodes && element.childNodes.length > 0) {
        return React.createElement(element.nodeName, element.attributes, render(element.childNodes, options) // eslint-disable-line
        );
    }
    return React.createElement(element.nodeName, element.attributes);
}
function render(nodes, options) {
    var elements = [];
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes.item(i);
        if (node.nodeType === dom_1.NodeType.TEXT_NODE) {
            elements.push(renderTextNode(node));
        }
        else if (node.nodeType === dom_1.NodeType.ELEMENT_NODE) {
            elements.push(renderElementNode(node, options));
        }
    }
    return elements;
}
exports.render = render;
//# sourceMappingURL=react.js.map